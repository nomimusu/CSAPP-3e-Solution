#include <stdio.h>

typedef unsigned float_bits;

float_bits float_half(float_bits f)
{
	unsigned sign = f >> 31;
	unsigned rest = f & 0x7fffffff;
	unsigned exp = f >> 23 & 0xff;
	unsigned frac = f & 0x7fffff;

	//如果f是无穷，那么f * 0.5也是无穷，且符号不会改变
	int NaN_or_∞ = (exp == 0xff);
	if (NaN_or_∞)
	{
		return f;
	}

	//设frac为0.XYY (X为1或0)
	// 0.X00 * 0.5 => 0.0X0 (浮点数的精度和范围能够表示0.X00*0.5的结果，所以不涉及舍入)，直接>>1即可；
	// 0.X01 * 0.5 => 0.0X0 （浮点数的精度和范围不能够表示0.X01*0.5的结果(X*1/4+1/16),这个时候需要寻找一个最接近的近似值）
	// 浮点数中最接近结果(X*1/4+1/16)值有(X*1/4)和(X*1/4+1/8),后者的话，最低有效位就会变成1，不符合向偶数舍入的规则，所以选择前者，所以直接>>1
	// 0.X10 * 0.5 => 0.0X1(浮点数的精度和范围能够表示0.X10*0.5的结果，所以不涉及舍入)，直接>>1即可；
	// 0.X11 * 0.5 => 0.0X1 （浮点数的精度和范围不能够表示0.X11*0.5的结果(X*1/4+1/8+1/16),这个时候需要寻找一个最接近的近似值）
	// 浮点数中最接近结果(X*1/4+1/8+1/16)值有(X*1/4+1/8+1/16+1/16)和(X*1/4+1/8),后者的话，最低有效位就会变成1，不符合向偶数舍入的规则，所以选择前者，所以直接>>1后再加1
	int additional = ((frac & 0x3) == 0x3);

	//*0.5，当exp == 1时，f会从规格数变成非规格数，由于规格数和非规格数计算数值的大小存在差异，所以需要进行一定的转换
	//*0.5，当exp == 0时，f为非规格数，此时frac*0.5，如果frac的最低有效位上是1，会涉及向偶数舍入的问题
	
	//非规格化数
	if (exp == 0)
	{
		frac >>= 1;
		frac += additional;
	}
	//从规格化数转化为非规格化数
	else if (exp == 1)
	{
		// V = (-1)^s * 2^(1-bias) * (1 + f) => V*0.5 = (-1)^s * 2^(1-bias) * (1/2+f/2);
		// 由于规格化数和非规格化数计算数值的方法不同，当exp == 1，V * 0.5，结果会变成非规格化数，数值为(-1)^s * 2^(1-bias) * (1/2+f/2)
		// (-1)^s * 2^(1-bias) * (1/2+f/2) => (-1)^s * 2^(1-bias)* 1/2 + (-1)^s * 2^(1-bias)*f/2
		// ret >> 1, 实现了三种结果
		// 结果一：exp的二进制位由0000 0001 变成 0000 0000
		// 结果二：原来exp的二进制位上的1，右移以后，到了frac权重为1/2的位上，实现了(-1)^s * 2^(1-bias) * 1/2
		// 结果三：frac右移1位，右移后frac的数值为 (-1)^s * 2^(1-bias)* f/2
		// (-1)^s * 2*(1-bias) * f * 1/2要符合偶数舍入的规则
		rest >>= 1;
		rest += additional;
		exp = rest >> 23 && 0xff;
		frac = rest & 0x7fffff;
	}
	else
	{
		exp -= 1;
	}

	return sign << 31 | exp << 23 | frac;
}
