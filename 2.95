#include <stdio.h>

typedef unsigned float_bits;

float_bits float_half(float_bits f)
{
	unsigned sign = f >> 31;
	unsigned rest = f & 0x7fffffff;
	unsigned exp = f >> 23 & 0xff;
	unsigned frac = f & 0x7fffff;

	//如果f是无穷，那么f * 0.5也是无穷，且符号不会改变
	int NaN_or_∞ = (exp == 0xff);
	if (NaN_or_∞)
	{
		return f;
	}

	//设frac为0.XYY (X为1或0)
	// 0.X00 * 0.5 => 0.0X0 (浮点数的精度和范围能够表示0.X00*0.5的结果，所以不涉及舍入)，直接>>1即可；
	// 0.X01 * 0.5 => 0.0X0 （浮点数的精度和范围不能够表示0.X01*0.5的结果(X*1/4+1/16),这个时候需要寻找一个最接近的近似值）
	// 浮点数中最接近结果(X*1/4+1/16)值有(X*1/4)和(X*1/4+1/8),后者的话，最低有效位就会变成1，不符合向偶数舍入的规则，所以选择前者，所以直接>>1
	// 0.X10 * 0.5 => 0.0X1(浮点数的精度和范围能够表示0.X10*0.5的结果，所以不涉及舍入)，直接>>1即可；
	// 0.X11 * 0.5 => 0.0X1 （浮点数的精度和范围不能够表示0.X11*0.5的结果(X*1/4+1/8+1/16),这个时候需要寻找一个最接近的近似值）
	// 浮点数中最接近结果(X*1/4+1/8+1/16)值有(X*1/4+1/8+1/16+1/16)和(X*1/4+1/8),后者的话，最低有效位就会变成1，不符合向偶数舍入的规则，所以选择前者，所以直接>>1后再加1
	int additional = ((frac & 0x3) == 0x3);

	//*0.5，当exp == 1时，f会从规格数变成非规格数，由于规格数和非规格数计算数值的大小存在差异，所以需要进行一定的转换
	//*0.5，当exp == 0时，f为非规格数，此时frac*0.5，如果frac的最低有效位上是1，会涉及向偶数舍入的问题
	
	//非规格化数
	if (exp == 0)
	{
		frac >>= 1;
		frac += additional;
	}
	//从规格化数转化为非规格化数
	else if (exp == 1)
	{
		// V = (-1)^s * 2^(1-bias) * (1 + f) => V*0.5 = (-1)^s * 2^(1-bias) * (1/2+f/2);
		// 由于规格化数和非规格化数计算数值的方法不同，当exp == 1，V * 0.5，结果会变成非规格化数
		// 计算机根据非规格化数的运算规则来运算值，结果是(-1)^s * 2*(1-bias) * f,可以看到该值和(-1)^s * 2^(1-bias) * (1/2+f/2)是不同的
		// 因此需要对(-1)^s * 2*(1-bias) * f进行一些修改，使其最接近(-1)^s * 2^(1-bias) * (1/2+f/2)
		// (-1)^s * 2^(1-bias) * (1/2+f/2) = (-1)^s * 2^(1-bias)*1/2 + (-1)^s * 2^(1-bias)*2/f
		// (-1)^s * 2^(1-bias)*1/2这个值远小于浮点数能够表示的范围，所以忽略不计
		// 所以(-1)^s * 2*(1-bias) * f * 1/2来接近(-1)^s * 2^(1-bias) * (1/2+f/2)
		// (-1)^s * 2*(1-bias) * f * 1/2要符合偶数舍入的规则
		rest >>= 1;
		rest += additional;
		exp = rest >> 23 && 0xff;
		frac = rest & 0x7fffff;
	}
	else
	{
		exp -= 1;
	}

	return sign << 31 | exp << 23 | frac;
}
