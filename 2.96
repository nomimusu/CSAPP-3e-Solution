// 理解题意：对于浮点数f，计算(int)f
// 假设浮点数f = 1.0, 32位的二进制位为 0 01111111 00000000000000000000000
// 那么(int)f = f' = 1, 32位的二进制位 0 00000000 00000000000000000000001
// 函数float_f2i()的左移就是将0 01111111 00000000000000000000000转换为 0 00000000 00000000000000000000001
// 当f超出int的取值范围 INT_MAX = 2^31 - 1, INT_MIN = -2^31，返回0x80000000, 其他情况，向零舍入

#include <stdio.h>

typedef unsigned float_bits;

int float_f2i(float_bits f)
{
	unsigned sig = f >> 31;
	unsigned exp = f >> 23 & 0xff;
	unsigned frac = f & 0x7fffff;
	unsigned bias = 0x7f;

	int num;
	unsigned E;
	unsigned M;

	// 浮点数V = (-1)^s * 2^E * M，所以可以先考虑f为正数的情况
	// 情况一：0 <= f < 1, 返回整数0
	// 0 00000000 00000000000000000000000
	// 0 00000000 00000000000000000000001
	// 0 00000000 00000000000000000000010
	// ====>
	// 0 01111111 00000000000000000000000

	// 情况二：1 <= f < 2^31,浮点数f在int的取值范围内，向零舍入
	// 0 01111111 00000000000000000000000
	// 0 01111111 00000000000000000000001
	// 0 01111111 00000000000000000000010
	// ======>
	// 0 (01111111+31) 00000000000000000000000

	// 情况三，2^31 <= f, 浮点数f超出int的取值范围，溢出，返回0x80000000
	// 0 (01111111+31) 00000000000000000000000
	// 0 (01111111+31) 00000000000000000000001
	// ......

	// 情况一
	if (exp >= 0 && exp < 0 + bias)
	{
		num = 0;
	}
	// 情况三
	// 也包括了浮点数f<0, (int)f == INT_MIN的情况
	else if (exp >= bias + 31)
	{
		num = 0x800000;
	}
	// 情况二
	// 此时浮点数f为规格化数，V = (-1)^s * 2^E * (1 + frac)
	else
	{
		E = exp - bias;
		// M = (1+frac)
		// frac = f & 0x7fffff,frac的值等于让小数字段frac右移了23位的值,即frac * 2^23
		// M的值对应的也要等于右移23位的值,即 M*2^23 = (1*2^23 + frac*2^23)
		// M*2^23 => V * 2^23 = (-1)^s * 2^E * (1+frac)*2^23
		// M的值右移23位的值为，frac | 0x800000;
		// 要计算V的值，可以对2^E 与 2^23的值进行比较，如果E = 23， 那么V = (-1)^s * (1+frac)*2^23
		// 如果E小于23, V = (-1)^s * (1+frac) * 2^23 * 2^(23-E)
		// 如果E大于23, V = (-1)^s * (1+frac) * 2^23 * 2^(E-23)
		// 上面三种情况，(1+frac) * 2^23为 M的值右移23位 frac | 0x800000
		M = frac | 0x800000;

		if (E >= 23)
		{
			num = M << (E - 23);
		}
		else
		{
			num = M >> (23 - E);
		}
	}

	return sig ? -num : num;

}
